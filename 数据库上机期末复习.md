### 1.like 模式匹配  
select * from book where bookname like "%经济学%";

### 2.as 重命名
select bookid as idofbook

select count(*) as count

### 3.exists

### 4.in

where <attr> in (select <attr>...) 常用于in后面的语句只返回一个值（如min,max）时，相当于给这个属性确定了一个值（有点类似于<attr>=...）

```mysql
	给出学号为“200810111”的同学最近一次借阅（借阅日期最大）的图书信息：
    select * from borrow where borrowdate in (select max(borrowdate) from borrow where stuid='200810111') and stuid='200810111' ;
    注意主语句也必须加上and stuid='200810111'，因为where borrowdate in返回的不是一张表，而只是最大的那个日期，不加的话stuid的限制条件就没了。
```



### 5.min,max  

### 注意：min必须用在select后面，即没有where bookid=min(bookid)的用法，因此不返回编号时必须嵌套查询

```mysql
    查找类别为c2的书中编号最小的书的信息（返回编号）：
    select min(bookid),bookname,author from book where catid="c2";
    返回编号时，min的属性和其他属性的值自动关联上了。
    
	如果不想返回编号，必须嵌套：
	select bookname,author from book where bookid in(select min(bookid)from book where catid="c2");
	
    给出所有研究生借阅图书的数目：
    select count(borrow.bookid) from student,borrow where student.degree="undergraduate" and student.stuid=borrow.stuid;
```

 

### 6.group by <attr> having <条件> 

 group by本质上是一个去重的作用，再配合having用来筛选
  group by必须写在where语句的后面（或者没有where语句）

  #### 经常用 select count(*) from <table> group by <attr>; 来求<attr>的每种取值出现的次数。

```mysql
  查找在'2010-10-1' 到 '2010-10-20'这段时间内bookid出现次数大于2的图书：
  select bookid from borrow where borrowdate between '2010-10-1' and '2010-10-20' group by bookid having count(*)>2;
```



7.order by,limit
    asc升序
    desc降序
    limit 取前n名

8.union,intersect,except 集合并交差

### 9.count(),count(*)
​    --在from后面嵌套语句可以建立临时表，必须给这张表起名（如P），就可以用P的某列了
​    --count(*)必须重命名（如borrowcount）才可以在其它语句输出
​    ---输出最多次数，可以先降序，再取第一名

```mysql
    给出借阅“c1”类别图书次数最多的学生。（stuid，stuname，borrowcount）
    select student.stuid,student.stuname,P.borrowcount
    from student,
     (select stuid,count(*) as borrowcount 
     from borrow,book 
     where book.catid='c1' and book.bookid=borrow.bookid group by stuid)P 
    where student.stuid=P.stuid order by P.borrowcount desc limit 1;
```



### 10.distinct去重

```mysql
给出借阅了所有图书类别的学生（stuid,stuname)
    select distinct student.stuid,student.stuname 
    from student,
    (select stuid,count(*)as catcount from
    (select distinct stuid,catid as countcat from borrow,book where book.bookid=borrow.bookid)pp group by stuid)P,
    (select count(*)as count from (select distinct catid from book)qq)Q
    where P.catcount=Q.count and student.stuid=P.stuid;
    
    pp:
    +------------+----------+
    | stuid      | countcat |
    +------------+----------+
    | 200810111  | c1       |
    | 200910121  | c1       |
    | 201021109  | c1       |
    | 201010121  | c1       |
    | 1201022135 | c1       |
    | 1200910211 | c1       |
    | 201021109  | c2       |
    | 200810111  | c2       |
    | 200810111  | c3       |
    | 200910121  | c3       |
    | 201010121  | c3       |
    | 1201022135 | c3       |
    | 200810111  | c4       |
    +------------+----------+
    P:去重后的pp表只要数stuid=xxx有几行，即可知道xxx有几类书了
    +------------+----------+
    | stuid      | catcount |
    +------------+----------+
    | 1200910211 |        1 |
    | 1201022135 |        2 |
    | 200810111  |        4 |
    | 200910121  |        2 |
    | 201010121  |        2 |
    | 201021109  |        2 |
    +------------+----------+


```

​    